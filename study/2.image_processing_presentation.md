# 히스토그램 

### 히스토그램이란?

어떤 데이터가 얼마나 많은지를 나타내는 도수 분포표를 그래프로 나타낸 것. 보통 히스토그램에서는 가로축이 계급, 세로축이 도수(빈도수)를 뜻한다.

![image](https://user-images.githubusercontent.com/23207379/51839842-c0772b00-234d-11e9-95e8-3466a8045072.png)


### 히스토그램의 장점

1. 그림(그래프)이기 때문에 데이터의 분포 상태를 한눈에 쉽게 알 수 있다.

2. 영상의 특성을 판단할 수 있는 유용한 도구가 된다.

### 히스토그램 그리기

    void calc_histo(cv::Mat image, cv::Mat &hist, int bins, int range_max = 256) {
        hist = cv::Mat(bins, 1, CV_32F, cv::Scalar(0));

        float gap = range_max / (float)bins;

        for(int i = 0; i < image.rows; i++) {
            for(int j = 0; j < image.cols; j++) {
                int idx = int(image.at<uchar>(i, j) / gap);
                hist.at<float>(idx)++;
            }
        }
    }
    
    int main() {
        cv::Mat image = cv::imread("/home/ryuitgo/사진/Lenna.png", cv::IMREAD_GRAYSCALE);
        CV_Assert(image.data);

        cv::Mat hist;
        calc_histo(image, hist, 256, 256);
        std::cout<< hist.t() << std::endl;

        cv::imshow("image", image);
        cv::waitKey(0);
        return 0;
    }

![image](https://user-images.githubusercontent.com/23207379/51851210-c88f9480-2366-11e9-951c-1ccc24e3f6f6.png)

### 히스토그램 스트레칭(stretching)

### 히스토그램 평활화(equalization)


# Convolution

### 공간 영역의 개념과 Convolution

화소 기반 처리가 화소값 각각에 대해 연산을 수행하는 것이라면, 공간 영역 기반 처리는 마스크(mask)라 불리는 규정된 영역을 기반으로 연산이 수행된다. 
이 마스크 기반 처리는 마스크 내의 원소값과 공간 영역에 있는 입력 영상의 화소값들을 대응되게 곱하여 출력화소값을 계산하는 것을 말한다. 이 처리 과정을 모든 출력 화소값에 대해 이동하면서 수행하는 것을 Convolution이라고 한다. 이때, 입력 영상에 곱해지는 이 마스크(mask)는 커널(kernel), 윈도우(window), 필터(filter) 등의 용어로도 불려진다.

![image](https://user-images.githubusercontent.com/23207379/51845695-5bc2cd00-235b-11e9-8062-f2b6977c6aa8.png)

위 그림은 3x3 크기의 마스크로 convolution을 수행하는 과정을 도식적으로 표현하였다. 출력화소는 대응되는 위치에 있는 입력화소와 마스크 크기만큼의 주위 화소들을 이용해서 계산된다. 즉, 마스크의 각 원소가 같은 위치의 입력화소와 곱해지며, 이 곱한 값들을 모두 더해서 출력화소가 계산된다. 같은 방법으로 입력 영상의 모든 화소에 대해서 마스크를 이동시켜서 곱하고, 그 값들을 모두 더해서 해당 위치의 출력화소가 계산된다.

이 마스크의 원소를 어떻게 결정하느냐에 따라서 결과 영상이 아주 다르게 결정된다. 

    void filter(cv::Mat img, cv::Mat& dst, cv::Mat mask) {

        dst = cv::Mat(img.size(), CV_32F, cv::Scalar(0));
        cv::Point h_m = mask.size() / 2;    //마스크 중심 좌표

        for(int i = h_m.y; i < img.rows - h_m.y; i++) {
            for(int j = h_m.x; j < img.cols - h_m.x; j++) {

                float sum = 0;

                for(int u = 0; u < mask.rows; u++) {
                    for( int v = 0; v < mask.cols; v++) {

                        int y = i + u - h_m.y;
                        int x = j + v - h_m.x;
                        sum += mask.at<float>(u, v) * img.at<uchar>(y,x);

                    }
                }

                dst.at<float>(i,j) = sum;
            }
        }
    }

### 블러링(blurrring)

마스크의 모든 원소의 값을 같게 구성해서 convolution을 수행하면 화소값이 급격하게 변하는 부분들을 감소시켜 점진적으로 변하게 함으로써 영상이 전체적으로 부드러운 느낌이 나게 된다. 

    float data[] = {
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f,
    };

![image](https://user-images.githubusercontent.com/23207379/51849702-9c264900-2363-11e9-8e0f-84979692c913.png)


### 샤프닝(sharpening)

마스크를 원소들의 값 차이가 커지도록 구성해서 convolution을 수행하면 출력화소에서 이웃 화소끼리 차이가 크게 나타나기 때문에 영상의 세세한 부분을 강조할 수 있고, 경계 부분에서 명암대비가 증가되는 효과를 낼 수 있다.

    float data1[] = {
        0, -1, 0,
        -1, 5, -1,
        0, -1, 0,
    };

    float data2[] = {
        -1, -1, -1,
        -1, 9, -1,
        -1, -1, -1,
    };
    
![image](https://user-images.githubusercontent.com/23207379/51850274-c4627780-2364-11e9-86db-3b05af5e31b4.png)

마스크 원소의 전체 합이 1이 되어야 입력 영상의 밝기가 손실 없이 출력 영상의 밝기로 유지된다.

# Morphology

### 침식 연산(erosion)

### 팽창 연산(dilation)

### 열림 연산과 닫힘 연산(opening, closing)

