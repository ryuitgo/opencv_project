# 히스토그램 

### 히스토그램이란?

![image](https://user-images.githubusercontent.com/23207379/51839842-c0772b00-234d-11e9-95e8-3466a8045072.png)

위 그림과 같이 어떤 데이터가 얼마나 많은지를 나타내는 도수 분포표를 그래프로 나타낸 것. 보통 히스토그램에서는 가로축이 계급, 세로축이 도수(빈도수)를 뜻한다.

### 히스토그램의 장점

1. 그림(그래프)이기 때문에 데이터의 분포 상태를 한눈에 쉽게 알 수 있다.

2. 영상의 특성을 판단할 수 있는 유용한 도구가 된다.

### 히스토그램 그리기

### 히스토그램 스트레칭(stretching)

### 히스토그램 평활화(equalization)


# Convolution

### 공간 영역의 개념과 Convolution

화소 기반 처리가 화소값 각각에 대해 연산을 수행하는 것이라면, 공간 영역 기반 처리는 마스크(mask)라 불리는 규정된 영역을 기반으로 연산이 수행된다. 
이 마스크 기반 처리는 마스크 내의 원소값과 공간 영역에 있는 입력 영상의 화소값들을 대응되게 곱하여 출력화소값을 계산하는 것을 말한다. 이 처리 과정을 모든 출력 화소값에 대해 이동하면서 수행하는 것을 Convolution이라고 한다. 이때, 입력 영상에 곱해지는 이 마스크(mask)는 커널(kernel), 윈도우(window), 필터(filter) 등의 용어로도 불려진다.

![image](https://user-images.githubusercontent.com/23207379/51845695-5bc2cd00-235b-11e9-8062-f2b6977c6aa8.png)

위 그림은 3x3 크기의 마스크로 convolution을 수행하는 과정을 도식적으로 표현하였다. 출력화소는 대응되는 위치에 있는 입력화소와 마스크 크기만큼의 주위 화소들을 이용해서 계산된다. 즉, 마스크의 각 원소가 같은 위치의 입력화소와 곱해지며, 이 곱한 값들을 모두 더해서 출력화소가 계산된다. 같은 방법으로 입력 영상의 모든 화소에 대해서 마스크를 이동시켜서 곱하고, 그 값들을 모두 더해서 해당 위치의 출력화소가 계산된다.

이 마스크의 원소를 어떻게 결정하느냐에 따라서 결과 영상이 아주 다르게 결정된다. 

### 블러링(blurrring)

전체 원소의 합이 1이고, 모든 원소의 값을 같게 구성한 마스크를 이용해서 convolution을 수행하는 코드를 작성하면 다음과 같다.

'''
#include <opencv2/opencv.hpp>

void filter(cv::Mat img, cv::Mat& dst, cv::Mat mask) {

    dst = cv::Mat(img.size(), CV_32F, cv::Scalar(0));
    cv::Point h_m = mask.size() / 2;    //마스크 중심 좌표

    for(int i = h_m.y; i < img.rows - h_m.y; i++) {
        for(int j = h_m.x; j < img.cols - h_m.x; j++) {

            float sum = 0;

            for(int u = 0; u < mask.rows; u++) {
                for( int v = 0; v < mask.cols; v++) {

                    int y = i + u - h_m.y;
                    int x = j + v - h_m.x;
                    sum += mask.at<float>(u, v) * img.at<uchar>(y,x);

                }
            }

            dst.at<float>(i,j) = sum;
        }
    }
}

int main() {
    cv::Mat image = cv::imread("/home/ryuitgo/사진/Lenna.png", cv::IMREAD_GRAYSCALE);
    CV_Assert(image.data);

    float data[] = {
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f
    };

    cv::Mat mask(3, 3, CV_32F, data);

    cv::Mat blur;

    filter(image, blur, mask);
    blur.convertTo(blur, CV_8U);

    cv::imshow("image", image);
    cv::imshow("blur", blur);
    cv::waitKey(0);
}
'''


### 샤프닝(sharpening)

# Morphology

### 침식 연산(erosion)

### 팽창 연산(dilation)

### 열림 연산과 닫힘 연산(opening, closing)

