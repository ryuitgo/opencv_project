# 히스토그램 

### 히스토그램이란?

어떤 이미지에서 특정값이 몇번이나 발생했는가를 보여주는 그래프이다. 가로축이 계급, 세로축이 도수(빈도수)를 뜻한다.

![image](https://user-images.githubusercontent.com/23207379/51839842-c0772b00-234d-11e9-95e8-3466a8045072.png)


### 히스토그램의 장점

1. 그림(그래프)이기 때문에 데이터의 분포 상태를 한눈에 쉽게 알 수 있다.

2. 영상의 특성을 판단할 수 있는 유용한 도구가 된다.

![image](https://user-images.githubusercontent.com/23207379/51421877-03682e80-1be9-11e9-9700-8c10e3cba317.png)

![image](https://user-images.githubusercontent.com/23207379/51856980-7190bc00-2374-11e9-9669-e9db58306b4a.png)

### 히스토그램 계산

![image](https://user-images.githubusercontent.com/23207379/51851210-c88f9480-2366-11e9-951c-1ccc24e3f6f6.png)

    void calc_histo(cv::Mat image, cv::Mat &hist, int bins, int range_max = 256) {
        hist = cv::Mat(bins, 1, CV_32F, cv::Scalar(0));

        float gap = range_max / (float)bins;

        for(int i = 0; i < image.rows; i++) {
            for(int j = 0; j < image.cols; j++) {
                int idx = int(image.at<uchar>(i, j) / gap);
                hist.at<float>(idx)++;
            }
        }
    }
    
    int main() {
        cv::Mat image = cv::imread("/home/ryuitgo/사진/Lenna.png", cv::IMREAD_GRAYSCALE);
        CV_Assert(image.data);

        cv::Mat hist;
        calc_histo(image, hist, 256, 256);
        std::cout<< hist.t() << std::endl;

        cv::imshow("image", image);
        cv::waitKey(0);
        return 0;
    }



### 히스토그램 그리기

![image](https://user-images.githubusercontent.com/23207379/51856079-18278d80-2372-11e9-87ca-c2c027a4dec5.png)

    void draw_histo(cv::Mat hist, cv::Mat &hist_img, cv::Size size = cv::Size(256,200)) {
        hist_img = cv::Mat(size, CV_8U, cv::Scalar(255));
        float bin = (float)hist_img.cols / hist.rows;
        cv::normalize(hist, hist, 0, hist_img.rows, cv::NORM_MINMAX);

        for(int i = 0; i < hist.rows; i++) {
            float start_x = i * bin;
            float end_x = (i + 1) * bin;

            cv::Point2f pt1(start_x, 0);
            cv::Point2f pt2(end_x, hist.at<float>(i));

            if(pt2.y > 0) {
                cv::rectangle(hist_img, pt1, pt2, cv::Scalar(0), -1);
            }
        }
        cv::flip(hist_img, hist_img, 0);
    }




### 히스토그램 평활화(equalization)

비슷한 값들로 뭉쳐진 영상을 인위적으로 넓게펴준다.

![image](https://user-images.githubusercontent.com/23207379/51853038-b0ba0f80-236a-11e9-81e6-a49818d6373b.png)

![image](https://user-images.githubusercontent.com/23207379/51853170-faa2f580-236a-11e9-970b-2d9a00e6a295.png)

---

#### 과정

1. 영상의 히스토그램을 계산한다.

![image](https://user-images.githubusercontent.com/23207379/51880877-50ec5480-23bc-11e9-93c7-52154f6a5aad.png)

2. 히스토그램 빈도값에서 누적 빈도수를 계산한다.

![image](https://user-images.githubusercontent.com/23207379/51880415-87c16b00-23ba-11e9-9cd1-d738aa1d0ec3.png)

3. 누적 빈도수를 정규화한다.

![image](https://user-images.githubusercontent.com/23207379/51880468-afb0ce80-23ba-11e9-92e5-274bce55f986.png)

![image](https://user-images.githubusercontent.com/23207379/51880489-c22b0800-23ba-11e9-82b8-0b0b953f1496.png)

4. 결과 

![image](https://user-images.githubusercontent.com/23207379/51880502-d242e780-23ba-11e9-9e44-51625433ed3c.png)



### 히스토그램 스트레칭(stretching)

![image](https://user-images.githubusercontent.com/23207379/51858622-840cf480-2378-11e9-9085-77368c02373e.png)



# Convolution

### 공간 영역의 개념과 Convolution

화소 기반 처리가 화소값 각각에 대해 연산을 수행하는 것이라면, 공간 영역 기반 처리는 마스크(mask)라 불리는 규정된 영역을 기반으로 연산이 수행된다. 
이 마스크 기반 처리는 마스크 내의 원소값과 공간 영역에 있는 입력 영상의 화소값들을 대응되게 곱하여 출력화소값을 계산하는 것을 말한다. 이 처리 과정을 모든 출력 화소값에 대해 이동하면서 수행하는 것을 Convolution이라고 한다. 이때, 입력 영상에 곱해지는 이 마스크(mask)는 커널(kernel), 윈도우(window), 필터(filter) 등의 용어로도 불려진다.

![image](https://user-images.githubusercontent.com/23207379/51845695-5bc2cd00-235b-11e9-8062-f2b6977c6aa8.png)

위 그림은 3x3 크기의 마스크로 convolution을 수행하는 과정을 도식적으로 표현하였다. 출력화소는 대응되는 위치에 있는 입력화소와 마스크 크기만큼의 주위 화소들을 이용해서 계산된다. 즉, 마스크의 각 원소가 같은 위치의 입력화소와 곱해지며, 이 곱한 값들을 모두 더해서 출력화소가 계산된다. 같은 방법으로 입력 영상의 모든 화소에 대해서 마스크를 이동시켜서 곱하고, 그 값들을 모두 더해서 해당 위치의 출력화소가 계산된다.

이 마스크의 원소를 어떻게 결정하느냐에 따라서 결과 영상이 아주 다르게 결정된다. 

    void filter(cv::Mat img, cv::Mat& dst, cv::Mat mask) {

        dst = cv::Mat(img.size(), CV_32F, cv::Scalar(0));
        cv::Point h_m = mask.size() / 2;    //마스크 중심 좌표

        for(int i = h_m.y; i < img.rows - h_m.y; i++) {
            for(int j = h_m.x; j < img.cols - h_m.x; j++) {

                float sum = 0;

                for(int u = 0; u < mask.rows; u++) {
                    for( int v = 0; v < mask.cols; v++) {

                        int y = i + u - h_m.y;
                        int x = j + v - h_m.x;
                        sum += mask.at<float>(u, v) * img.at<uchar>(y,x);

                    }
                }

                dst.at<float>(i,j) = sum;
            }
        }
    }

### 블러링(blurrring)

마스크의 모든 원소의 값을 같게 구성해서 convolution을 수행하면 화소값이 급격하게 변하는 부분들을 감소시켜 점진적으로 변하게 함으로써 영상이 전체적으로 부드러운 느낌이 나게 된다. 

    float data[] = {
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f,
        1 / 9.f, 1 / 9.f, 1 / 9.f,
    };

![image](https://user-images.githubusercontent.com/23207379/51849702-9c264900-2363-11e9-8e0f-84979692c913.png)


### 샤프닝(sharpening)

마스크를 원소들의 값 차이가 커지도록 구성해서 convolution을 수행하면 출력화소에서 이웃 화소끼리 차이가 크게 나타나기 때문에 영상의 세세한 부분을 강조할 수 있고, 경계 부분에서 명암대비가 증가되는 효과를 낼 수 있다.

    float data1[] = {
        0, -1, 0,
        -1, 5, -1,
        0, -1, 0,
    };

    float data2[] = {
        -1, -1, -1,
        -1, 9, -1,
        -1, -1, -1,
    };
    
![image](https://user-images.githubusercontent.com/23207379/51850274-c4627780-2364-11e9-86db-3b05af5e31b4.png)

마스크 원소의 전체 합이 1이 되어야 입력 영상의 밝기가 손실 없이 출력 영상의 밝기로 유지된다.

# 컬러 공간

![image](https://user-images.githubusercontent.com/23207379/51434830-02003a00-1cad-11e9-8dad-86e920a83527.png)

### RGB

빛의 삼원색(빨강,초록,파랑)을 축으로 설정하여 만든 3차원 좌표계. 빛을 물리적으로 표현하고 만드는데 사용되는 기본 컬러 공간.

### HSV

인간이 컬러 영상 정보를 인지하는 방법인 색상(Hue), 채도(Saturation), 명도(Intensity)를 축으로 설정하여 만든 3차원 공간

### YCrCb

인간의 시각은 밝기에 민감하지만 색상에는 덜 민감하다는 점을 이용해서 색차 신호인 Cr, Cb 성분을 휘도 성분인 Y 성분보다 상대적으로 낮은 해상도로 구성함

-> 인간의 시각에서 화질의 큰 저하 없이 영상 데이터의 용량을 감소할 수 있다. 
